
var gvariant = require('../gvariant');
var assert = require('assert');

function test(type, data, value) {
    var buf = new Buffer(data);

    var parsed = gvariant.parse(type, buf);
    assert.deepStrictEqual(parsed, value);
}

describe('gvariant.parse()', function () {

    it('should throw an error when passed invalid type strings', function () {
        assert.throws(function () { gvariant.parse('bb'); }, TypeError);
        assert.throws(function () { gvariant.parse(''); }, TypeError);
        assert.throws(function () { gvariant.parse('Ã¤'); }, TypeError);
        assert.throws(function () { gvariant.parse('(a'); }, TypeError);
    });

    it('should map gvariant booleans to javascript booleans', function () {
        test('b', [ 0x0 ], false);
        test('b', [ 0x1 ], true);
    });

    it('should map gvariant integer types to javascript numbers', function () {
        test('y', [ 0x2a ], 42);

        test('n', [ 0xd6, 0xff ], -42);
        test('q', [ 0x2a, 0x0 ], 42);

        test('i', [ 0xd6, 0xff, 0xff, 0xff ], -42);
        test('u', [ 0x2a, 0x0, 0x0, 0x0 ], 42);

        test('x', [ 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff ], -42);
        test('t', [ 0x2a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 ], 42);
    });

    it('should be able to read large integers', function () {
        ['x', 't'].forEach(function (type) {
            test(type, [ 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 ], 96);
            test(type, [ 0x0, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 ], 3072);
            test(type, [ 0x0, 0x80, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0 ], 98304);
            test(type, [ 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0 ], 3145728);
            test(type, [ 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0 ], 100663296);
            test(type, [ 0x0, 0x0, 0x0, 0xc0, 0x0, 0x0, 0x0, 0x0 ], 3221225472);
            test(type, [ 0x0, 0x0, 0x0, 0x0, 0x18, 0x0, 0x0, 0x0 ], 103079215104);
            test(type, [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0 ], 3298534883328);
            test(type, [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0 ], 105553116266496);
            test(type, [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0 ], 3377699720527872);
        });

        test('x', [ 0xa0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff ], -96);
        test('x', [ 0x0, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff ], -3072);
        test('x', [ 0x0, 0x80, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff ], -98304);
        test('x', [ 0x0, 0x0, 0xd0, 0xff, 0xff, 0xff, 0xff, 0xff ], -3145728);
        test('x', [ 0x0, 0x0, 0x0, 0xfa, 0xff, 0xff, 0xff, 0xff ], -100663296);
        test('x', [ 0x0, 0x0, 0x0, 0x40, 0xff, 0xff, 0xff, 0xff ], -3221225472);
        test('x', [ 0x0, 0x0, 0x0, 0x0, 0xe8, 0xff, 0xff, 0xff ], -103079215104);
        test('x', [ 0x0, 0x0, 0x0, 0x0, 0x0, 0xfd, 0xff, 0xff ], -3298534883328);
        test('x', [ 0x0, 0x0, 0x0, 0x0, 0x0, 0xa0, 0xff, 0xff ], -105553116266496);
        test('x', [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf4, 0xff ], -3377699720527872);
    });

    it('should map gvariant doubles to javascript numbers', function () {
        test('d', [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x45, 0x40 ], 42.5);
    });

    it('should map gvariant strings to javascript strings', function () {
        test('s', [ 0x0 ], '');
        test('s', [ 0x61, 0x62, 0x63, 0x0 ], 'abc');
    });

    it('should map variants to an object with the variant\'s type and value', function () {
        test('v', [ 0x2a, 0x0, 0x0, 0x0, 0x0, 0x69 ], { type: 'i', value: 42 });
        test('v', [ 0x2a, 0x0, 0x61, 0x79 ], { type: 'ay', value: [ 42 ] });
    });

    it('should map maybes to null or their contents', function () {
        test('my', [], null);
        test('my', [ 0x2a ], 42);
        test('ms', [], null);
        test('ms', [ 0x61, 0x62, 0x63, 0x0, 0x0 ], 'abc');
    });

    it('should map arrays to javascript arrays', function () {
        test('ay', [], []);
        test('ay', [ 0x1, 0x2, 0x3 ], [1, 2, 3]);
        test('as', [], []);
        test('as', [ 0x61, 0x62, 0x63, 0x0, 0x78, 0x0, 0x79, 0x7a, 0x0, 0x4, 0x6, 0x9 ], [ 'abc', 'x', 'yz' ]);
    });

    it('should map tuples to javascript arrays', function () {
        test('()', [], []);
        test('(bus)', [ 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x61, 0x62, 0x63, 0x0 ], [ true, 42, 'abc' ]);
        test('(bsy)', [ 0x1, 0x61, 0x62, 0x63, 0x0, 0x2a, 0x5 ], [ true, 'abc', 42 ]);
    });

    it('should map dictionaries to javascript objects', function () {
        test('a{sv}', [], {});
        test('a{sv}', [ 0x61, 0x62, 0x63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x0, 0x69, 0x4, 0x0,
                        0x64, 0x65, 0x66, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2b, 0x0, 0x0, 0x0, 0x0, 0x69, 0x4, 0xf, 0x1f ],
                      { abc: { type: 'i', value: 42 }, def: { type: 'i', value: 43 } });
    });

    describe('should handle non-normal serialized data:', function () {

        it('wrong size for fixed size value', function () {
            test('b', [ 0x1, 0x1, 0x1 ], false);
            test('y', [], 0);
            test('u', [ 0x0, 0x1 ], 0);
            test('x', [ 0x0, 0x1, 0x2, 0x3 ], 0);
        });

        it('boolean out of range', function () {
            test('b', [ 0x2a ], true);
        });

        it('possibly unterminated string', function () {
            test('s', [ 0x61 ], '');
        });

        it('string with embedded nul', function () {
            test('s', [ 0x61, 0x0, 0x61, 0x0  ], 'a');
        });

        it('wrong size for fixed size maybe', function () {
            test('my', [ ], null);
            test('mu', [ 0x1, 0x2, 0x3, 0x4, 0x5], null);
        });

        it('wrong size for fixed width array', function () {
            test('aq', [ 0x1 ], []);
        });
    });
});
